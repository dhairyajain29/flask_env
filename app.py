from flask import Flask, jsonify, request
import mysql.connector
from mysql.connector import errorcode

app = Flask(__name__)

# Database configuration
db_config = {
    'user': 'root',
    'password': 'root@123',
    'host': 'localhost',
    'database': 'datamodel',
}

# Function to connect to the database
def get_db_connection():
    try:
        conn = mysql.connector.connect(**db_config)
        return conn
    except mysql.connector.Error as err:
        if err.errno == errorcode.ER_ACCESS_DENIED_ERROR:
            print("Something is wrong with your user name or password")
        elif err.errno == errorcode.ER_BAD_DB_ERROR:
            print("Database does not exist")
        else:
            print(err)
        return None

@app.route('/')
def index():
    return "Welcome to the Flask API!"

@app.route('/orders', methods=['GET'])
def get_all_orders():
    conn = get_db_connection()
    if conn:
        cursor = conn.cursor(dictionary=True)
        cursor.execute("SELECT * FROM Order_Header")  # Updated table name
        orders_data = cursor.fetchall()
        cursor.close()
        conn.close()
        return jsonify(orders_data), 200
    else:
        return jsonify({"message": "Database connection failed"}), 500

@app.route('/orders', methods=['POST'])
def create_order():
    data = request.json
    conn = get_db_connection()
    if conn:
        try:
            cursor = conn.cursor()
            # Updated table name and assuming 'OrderName' and 'OrderDate' are fields in your 'Order_Header' table
            query = "INSERT INTO Order_Header (OrderName, OrderDate) VALUES (%s, %s)"
            cursor.execute(query, (data['OrderName'], data['OrderDate']))
            order_id = cursor.lastrowid  # Get the last inserted id
            conn.commit()
            cursor.close()
            conn.close()
            return jsonify({"orderId": order_id, "message": "Order created successfully"}), 201
        except mysql.connector.Error as err:
            print(err)
            return jsonify({"message": "Failed to create order"}), 500
    else:
        return jsonify({"message": "Database connection failed"}), 500

@app.route('/orders/<order_id>', methods=['GET'])
def get_order(order_id):
    conn = get_db_connection()
    if conn:
        cursor = conn.cursor(dictionary=True)
        cursor.execute("SELECT * FROM Order_Header WHERE OrderID = %s", (order_id,))  # Updated table name and field
        order_data = cursor.fetchone()
        cursor.close()
        conn.close()
        if order_data:
            return jsonify(order_data), 200
        else:
            return jsonify({"message": "Order not found"}), 404
    else:
        return jsonify({"message": "Database connection failed"}), 500

@app.route('/orders/<order_id>', methods=['PUT'])
def update_order(order_id):
    data = request.json
    conn = get_db_connection()
    if conn:
        try:
            cursor = conn.cursor()
            # Here you would update your order based on the `order_id` and data provided.
            # For example, if you're updating the order name and date:
            query = "UPDATE Order_Header SET OrderName = %s, OrderDate = %s WHERE OrderID = %s"
            cursor.execute(query, (data['OrderName'], data['OrderDate'], order_id))
            conn.commit()
            cursor.close()
            conn.close()
            if cursor.rowcount == 0:
                return jsonify({"message": "Order not found"}), 404
            return jsonify({"message": "Order updated successfully"}), 200
        except mysql.connector.Error as err:
            print(err)
            return jsonify({"message": "Failed to update order"}), 500
    else:
        return jsonify({"message": "Database connection failed"}), 500
    

    from flask import Flask, request, jsonify
from db import get_db_connection

app = Flask(__name__)

@app.route('/orders', methods=['POST'])
def create_order():
    # Get the JSON data from the request
    data = request.json

    # Check if the required fields are present in the request data
    if 'OrderName' not in data or 'PlacedDate' not in data:
        return jsonify({"message": "Missing required fields"}), 400

    # Extract the data from the request
    order_id = data.get('OrderId')  # If provided, otherwise generated by the database
    order_name = data['OrderName']
    placed_date = data['PlacedDate']
    approved_date = data.get('ApprovedDate', None)  # Optional field
    status_id = data.get('StatusId', None)  # Optional field
    currency_uom_id = data.get('CurrencyUomId', 'USD')  # Default value
    product_store_id = data.get('ProductStoreId', None)  # Optional field
    sales_channel_enum_id = data.get('SalesChannelEnumId', None)  # Optional field
    grand_total = data.get('GrandTotal', None)  # Optional field
    completed_date = data.get('CompletedDate', None)  # Optional field

    # Insert the order into the database
    conn = get_db_connection()  # Establish a database connection

    if conn:
        try:
            cursor = conn.cursor()
            # Define the SQL query to insert the order into Order_Header
            query = """INSERT INTO Order_Header (ORDER_ID, ORDER_NAME, PLACED_DATE, APPROVED_DATE,
                       STATUS_ID, CURRENCY_UOM_ID, PRODUCT_STORE_ID, SALES_CHANNEL_ENUM_ID,
                       GRAND_TOTAL, COMPLETED_DATE)
                       VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s)"""
            cursor.execute(query, (order_id, order_name, placed_date, approved_date, status_id,
                                   currency_uom_id, product_store_id, sales_channel_enum_id,
                                   grand_total, completed_date))
            conn.commit()
            cursor.close()
            conn.close()
            return jsonify({"message": "Order created successfully"}), 201
        except Exception as e:
            return jsonify({"message": f"Failed to create order: {str(e)}"}), 500
    else:
        return jsonify({"message": "Database connection failed"}), 500

if __name__ == '__main__':
    app.run(debug=True)


# Additional routes for handling persons would go here

if __name__ == '__main__':
    app.run(debug=True)
